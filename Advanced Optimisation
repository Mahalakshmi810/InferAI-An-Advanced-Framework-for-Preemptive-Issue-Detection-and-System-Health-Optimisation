import streamlit as st
import psutil
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from datetime import datetime
import time

# ---------------- Page Config ----------------
st.set_page_config(page_title="InferAI PRO", layout="wide", page_icon="âš¡")

# ---------------- Advanced CSS ----------------
st.markdown("""
<style>
body, .stApp {background-color:#0E1117; color:#FF4500; font-family:'Segoe UI', sans-serif;}
[data-testid="stSidebar"] {background-color:#000 !important; border-right: 1px solid #FF4500;}
.stMetric {background: #161B22; border: 1px solid #30363D; border-radius: 10px; padding: 15px;}
.risk-card {
    padding: 20px; border-radius: 15px; background: rgba(255, 69, 0, 0.1);
    border: 2px solid #FF4500; margin-bottom: 20px; text-align: center;
}
.failure-log {
    font-family: 'Courier New', monospace; font-size: 13px; background: #000;
    color: #00FF00; padding: 15px; border-radius: 5px; height: 250px; overflow-y: scroll; border: 1px solid #333;
}
</style>
""", unsafe_allow_html=True)

# ---------------- Initialize Persistent State ----------------
if "log_data" not in st.session_state:
    st.session_state.log_data = []
if "hist_df" not in st.session_state:
    st.session_state.hist_df = pd.DataFrame(columns=['Time', 'CPU', 'Mem', 'Risk'])

# ---------------- Title ----------------
st.markdown('<h1 style="text-align:center; color:white;">âš¡ INFERAI PRO</h1>', unsafe_allow_html=True)
st.markdown('<p style="text-align:center; color:#FF4500;">Deep Kernel & Hardware Failure Prediction Engine</p>', unsafe_allow_html=True)

# ---------------- Sidebar ----------------
st.sidebar.title("ðŸ›¡ï¸ Engine Status")
status_placeholder = st.sidebar.empty()
update_interval = st.sidebar.slider("Scan Speed (Seconds)", 0.5, 5.0, 1.0)

# ---------------- Failure Detection Engine ----------------
def run_deep_scan():
    cpu = psutil.cpu_percent()
    mem = psutil.virtual_memory().percent
    swap = psutil.swap_memory().percent
    
    zombies = len([p for p in psutil.process_iter(['status']) if p.info['status'] == psutil.STATUS_ZOMBIE])
    
    try:
        io_wait = psutil.cpu_times_percent().iowait
    except: io_wait = 0.0
    
    risk = 0
    alerts = []
    if cpu > 85: risk += 20; alerts.append("THERMAL: High sustained CPU load detected.")
    if swap > 25: risk += 30; alerts.append("HARDWARE: RAM Bank failure/Swap thrashing.")
    if io_wait > 10: risk += 25; alerts.append("STORAGE: Mechanical disk latency anomaly.")
    if zombies > 0: risk += 15; alerts.append("KERNEL: OS Process Table Leak (Zombies).")
    
    return cpu, mem, swap, io_wait, zombies, min(risk, 100), alerts

# ---------------- Main Dashboard Loop ----------------
main_placeholder = st.empty()

while True:
    status_placeholder.markdown("ðŸŸ¢ **SENSOR STATUS: ACTIVE SCANNING**")
    cpu, mem, swap, io_wait, zombies, risk, alerts = run_deep_scan()
    timestamp = datetime.now().strftime("%H:%M:%S")
    
    log_entry = f"[{timestamp}] RISK: {risk}% | CPU: {cpu}% | MEM: {mem}% | IO: {io_wait}%"
    st.session_state.log_data.append(log_entry)
    if len(st.session_state.log_data) > 50: st.session_state.log_data.pop(0)
    
    new_point = pd.DataFrame([[timestamp, cpu, mem, risk]], columns=['Time', 'CPU', 'Mem', 'Risk'])
    st.session_state.hist_df = pd.concat([st.session_state.hist_df, new_point], ignore_index=True).tail(100)

    with main_placeholder.container():
        # Top Row: All three major cards now highlighted
        c1, c2, c3 = st.columns(3)
        
        with c1:
            st.markdown(f"""
            <div class="risk-card">
                <h3 style="color:white; margin:0; font-size:18px;">FAILURE PROBABILITY</h3>
                <h1 style="font-size: 50px; color: {'#FF4500' if risk > 50 else '#00FF00'}; margin:10px 0;">{risk}%</h1>
                <p style="color:white; font-weight:bold; margin:0;">{'SYSTEM DEGRADED' if risk > 40 else 'OPTIMAL HEALTH'}</p>
            </div>
            """, unsafe_allow_html=True)

        with c2:
            st.markdown(f"""
            <div class="risk-card">
                <h3 style="color:white; margin:0; font-size:18px;">CPU HEAT STRESS</h3>
                <h1 style="font-size: 50px; color: {'#FF4500' if cpu > 85 else '#00FF00'}; margin:10px 0;">{cpu}%</h1>
                <p style="color:white; font-weight:bold; margin:0;">{'WARNING: HIGH TEMP' if cpu > 85 else 'THERMAL STABLE'}</p>
            </div>
            """, unsafe_allow_html=True)

        with c3:
            st.markdown(f"""
            <div class="risk-card">
                <h3 style="color:white; margin:0; font-size:18px;">OS STABILITY</h3>
                <h1 style="font-size: 50px; color: {'#00FF00' if zombies == 0 else '#FF4500'}; margin:10px 0;">{100-risk}%</h1>
                <p style="color:white; font-weight:bold; margin:0;">ZOMBIES: {zombies}</p>
            </div>
            """, unsafe_allow_html=True)

        col_left, col_right = st.columns(2)
        
        with col_left:
            st.subheader("ðŸš¨ Failure Diagnostics")
            if not alerts:
                st.success("Hardware and Software layers are performing within safety bounds.")
            else:
                for a in alerts:
                    st.error(a)

        with col_right:
            st.subheader("ðŸ“œ Predictive Scan Log")
            log_html = f"<div class='failure-log'>{'<br>'.join(reversed(st.session_state.log_data))}</div>"
            st.markdown(log_html, unsafe_allow_html=True)

        st.subheader("ðŸ“Š Stress Distribution Over Time")
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=st.session_state.hist_df['Time'], y=st.session_state.hist_df['CPU'], name="CPU Load", line=dict(color='#FF4500')))
        fig.add_trace(go.Scatter(x=st.session_state.hist_df['Time'], y=st.session_state.hist_df['Risk'], name="Risk %", line=dict(color='#FFFFFF', dash='dot')))
        fig.update_layout(template="plotly_dark", paper_bgcolor="rgba(0,0,0,0)", plot_bgcolor="rgba(0,0,0,0)", height=300, margin=dict(l=0,r=0,t=0,b=0))
        st.plotly_chart(fig, use_container_width=True, key=f"chart_{time.time()}")

    time.sleep(update_interval)
